---
layout: post
title: "[OS] Process vs Thread"
categories: cs
---

* this unordered seed list will be replaced by toc as unordered list
{:toc}

## 프로세스

- 프로세스는 컴퓨터 프로그램의 인스턴스로 하나 이상의 스레드를 통해 실행됨
- 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태

### 멀티 태스킹

- OS 를 통해 CPU 가 작업하는데 필요한 자원(시간)을 프로세스 또는 스레드 간에 나누는 행위
- 컴퓨터에서 여러 프로세스가 동시에 실행되고 있는 것처럼 보이지만 사실은 CPU가 여러 프로세스들을 번갈아 실행하고 관리하는 것

### 컨텍스트 스위치

- 하나의 프로세스가 CPU 를 사용 중인 상태에서 다른 프로세스가 CPU 를 사용하도록 하기 위해, 이전의 프로세스 상태(PCB)를 저장하고 새로운 프로세스의 상태를 적재하는 것
- 컨텍스트 스위칭은 운영체제의 CPU 자원을 관리/할당하는 스케줄러에 의해 발생
- 메모리 IO가 발생하기 때문에 빈번한 컨텍스트 스위칭은 성능 저하의 원인

### CPU 스케줄러

- 멀티 태스킹 작업에 있어 핵심적인 역할
- 레디 큐에 존재하는 프로세스들을 특정한 우선순위 기반으로 CPU를 할당받게 함
- 다양한 스케줄링 알고리즘
	- FCFS: 선착순
	- SJF: 최단 작업 우선
	- RR: 일정 시간 주기로
	- Multilevel-Queue: 레디 큐 여러개. 큐마다 다른 알고리즘
	- Multilevel-Feedback-Queue: Multilevel-Queue인데 큐 간 이동 가능

### PCB와 프로세스 상태

#### PCB

- Process Control Block
- 프로세스 관리를 위해 필요한 정보. 컨텍스트 스위칭 때문에 필요

![pcb](/assets/img/pcb.png)

#### 프로세스 상태

- new
- ready
- running
- waiting
- terminated

### 메모리 영역

#### 코드 영역

- 프로그램 코드 및 매크로 상수가 기계어 형태로 저장
- CPU는 코드영역에 저장된 명령어를 하나씩 처리

#### 데이터 영역

- 전역 변수와 정적 변수가 저장됨
- 프로그램 시작과 함께 할당되어 종료시 소멸

#### 스택 영역

- 함수, 지역 변수, 함수 매개변수, 함수 리턴값 등 저장
- LIFO 매커니즘

#### 힙 영역

- 동적 메모리 할당 공간(Free Space)
- 사용이 끝나면 OS가 사용할 수 있도록 반납해야 함

![process](/assets/img/process.png)

### IPC (Inter-Process Communication)

- 각 프로세스는 별도의 공간에서 실행되기 때문에 서로의 메모리 영역에 접근할 수 없음
- 프로세스 간 자원 공유를 위해서는 IPC 를 사용해야 함
- IPC 종류로는 메일슬롯, 파이프, 소켓, 시그널, 공유메모리 등이 있음

## 스레드

- 프로세스 내에서 실행되는 흐름의 단위
- 하나의 프로세스는 반드시 하나 이상의 스레드를 가짐

### 스레드의 메모리 영역

- 프로세스 내에서 스택 영역만 별도로 할당 받고, 부모 프로세스 내 힙, 데이터, 코드 영역은 공유
- 프로세스 내에서 자식 스레드들은 서로 주소 공간이나 자원들을 공유할 수 있음

![thread](/assets/img/thread.png)

## 멀티 프로세스와 멀티 스레드

### 멀티 프로세스

- 하나의 어플리케이션을 여러 개의 프로세스로 구성하여 각각 하나의 작업을 처리
- 안정성이 좋음. 자식 프로세스 중 하나에 문제가 발생해도 영향이 확산되지 않음
- 구현이 비교적 간단함(각 프로세스들이 독립적으로 동작. 자원도 다르게 할당)
- 프로세스 간 통신을 위해서는 IPC 가 필요
- 메모리 사용량이 많음
- 스케줄링에 따른 컨텍스트 스위치가 많아지고 성능 저하 우려가 있음

### 멀티 스레드

- 하나의 어플리케이션을 여러 개의 스레드로 구성하여 각각 하나의 작업을 처리
- 단일 스레드로 DB나 네트워크 작업을 하는 경우, 해당 작업을 처리하는 동안 사용자와 상호작용 등이 불가하기 때문에 이런 경우에 사용함
- 응답성이 좋음. 프로그램 일부분이 오류 또는 긴 작업으로 인해 중단되어도 프로그램을 계속 수행
- 자원 공유가 쉬움. 부모 프로세스의 자원을 공유
- 컨텍스트 스위칭 비용이 적음(스택 영역만 처리)
- 프로세스 생성 비용보다 스레드 생성 비용이 적음
- 구현이 어려움. 디버깅도 어려움. 동기화, 데드락이 발생하지 않도록 주의
- 자식 스레드 중 문제가 생기면 전체 프로세스에 영향을 줄 수 있음(공유 자원 관련..)

![multi-thread](/assets/img/multi-thread.png)

## 참고

- <https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37>