---
layout: post
title: "[네트워크] 전송 계층 Transport Layer"
categories: network
---

0. this unordered seed list will be replaced by toc as unordered list
{:toc}

## 데이터 단위

* TCP: 세그먼트
* UDP: 데이터그램

## 특징

* 목적지까지 데이터가 잘 도착하도록 하는 것
* 연결 지향 데이터 스트림, 멀티플렉싱, 신뢰성 있는 데이터 전송, 흐름 제어, 다중화 등의 서비스 (대부분 TCP가 제공하는 기능들)를 제공
* TCP 경우, 호스트에서만 작동하고 중간 라우터 노드들에서는 작동하지 않음 (TCP는 복잡한 처리를 요구하기 때문에 중간 라우터 노드들에까지 TCP를 작동하게 한다면 지금처럼 많은 데이터 처리가 어려움)

## TCP 프로토콜 (Transmission Control Protocol)

### 연결 지향 프로토콜 (Connection Oriented Protocol)

* 통신 연결이 유지되는 것을 지향 (전화 연결이 적절한 예)
* 통신을 유지하기 위해 비용이 비쌈
* IP 프로토콜은 비연결 프로토콜이지만, IP 프로토콜을 이용하는 TCP는 연결 지향 프로토콜임. 반면, TCP를 이용하는 HTTP는 비연결 프로토콜 (프로토콜을 어떻게 활용하느냐에 따라 연결 지향과 비연결 프로토콜로 바뀔 수 있음)
* 비연결 프로토콜에서는 매번 새롭게 연결이 성립되기 때문에 매 연결 시 자신이 누군지 알려주어야 함 (예를 들어 HTTP 이용한 웹 환경의 경우 쿠키나 세션을 통해 매번 자신을 식별할 수 있는 정보를 함께 전송함)

![tcp_header](/assets/img/tcp_header.PNG)

### 멀티플렉싱 (Multiplexing)

하나의 호스트에는 여러 응용 프로그램이 존재할 수 있고 따라서 여러 소켓이 존재한다. 그러나 컴퓨터에 연결된 통신 링크는 하나이기 때문에 이들을 서로 구분하여야 한다. 이를 위해 TCP 계층에서는 세그먼트를 만들 때 헤더를 추가하여 출발지 포트 번호와 목적지 포트 번호를 두는 데, 이 작업을 멀티플렉싱이라고 한다.


목적지에 도착한 세그먼트는 헤더 확인을 통해 디멀티플렉싱 된 뒤 해당 소켓에게 데이터를 전달된다.

### 신뢰성 있는 통신 (Reliable Data Transfer, RDT)

잘못된 데이터를 송신하지 않고, 데이터의 순서가 유지되는 통신을 보장한다는 뜻


* rdt 1.0 : 데이터 전송에 에러가 발생하지 않는다는 가정. 받은 데이터를 패킷으로 만들고 udt_send
* rdt 2.0 : 비트 에러가 존재할 수 있는 상황. 비트 에러 감지를 위해 체크섬도 송신함. 수신인으로부터 ACK 혹은 NACK 를 받고 그에 따라 액션을 취함. (ARQ, Automatic Repeat reQuest)
* rdt 2.1 : 중복 수신을 방지하기 위해 순서 번호를 추가. 방금 전송한 패킷이 잘 전송되었는지만 확인하면 되기 때문에 0, 1만 있으면 됨. 0에 대한 패킷 전송 완료 후에 1에 대한 패킷을 보내는 식.
* rdt 2.2 : ACK에 순서번호를 추가하여 NACK를 ACK로 대체할 수 있음.
* rdt 3.0 : 패킷이 손실되는 경우. 시간 내에 데이터를 성공적으로 수신했다는 응답을 받지 못하면 데이터를 다시 보냄. 중복된 수신에 대해서는 이미 rdt 2.2 상에서 처리 가능.

rdt 3.0을 통해 신뢰성 있는 통신이 가능해졌지만, 한 번에 한 패킷 밖에 보내지 못하기 때문에 성능상 만족스럽지 못하다. 여러 패킷을 한꺼번에 보내기 위해 GBN, SR 프로토콜이 있다.

#### GBN (Go-Back-N)

![gbn](/assets/img/gbn.PNG)

window를 통해 여러 패킷을 한꺼번에 보낼 수 있음. 위 그림에서, 윈도우 사이즈가 7이므로 0~6까지 7개의 프레임을 보낼 수 있으며, 2,3,4 를 보내고 있는 와중에 0,1에 대한 ACK가 왔기 때문에 윈도우 사이즈를 늘린 모습을 볼 수 있다. 단점은 패킷 하나의 오류 때문에 많은 패킷들을 재전송하게 된다는 것이다. 0에 대한 ACK가 오지 않는 경우 0부터 다시 보내야 됨. 순서가 뒤바뀌어 도착한 패킷들은 버려짐.

#### SR (Selective Repeat)

![sr](/assets/img/sr.PNG)

문제가 발생한 패킷만 재전송. 따라서 순서가 꼬일 수도 있기 때문에 패킷 재정렬을 위해 별도의 버퍼가 필요함.

### 연결 제어 (Connection Control)

앞서 말한대로 TCP는 연결 지향 프로토콜이기 때문에 서로 데이터를 전송하기 전에 연결 성립(Establish)이 필요함

#### 3-way handshaking

* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장
* 양쪽 모두 상대편에 대한 초기 순서 번호를 얻을 수 있도록 함

![3way](/assets/img/3way.PNG)

1. Client는 연결하자는 뜻으로 SYN 패킷과 함께 초기 순서 번호를 Server에게 보냄
2. Server는 Client의 초기 순서 번호가 M인 것을 알게 되고, SYN+ACK 패킷과 함께 자신의 초기 순서 번호를 보냄
3. 마지막으로 Client는 Server의 초기 순서 번호를 잘 받았다는 의미로 ACK를 보냄

#### 4-way handshaking

연결 종료를 위함

![4way](/assets/img/4way.PNG)

1. Client가 연결을 종료하겠다는 FIN 플래그는 전송 (FIN_WAIT)
2. Server는 FIN 플래그를 받고 Client에게 ACK를 보낸 후, 자신의 통신이 끝날 때 까지 기다림 (CLOSE_WAIT)
3. Server가 연결을 종료할 준비가 되면, Client에게 FIN 플래그를 전송 (LAST_ACK)
4. Client는 Server의 FIN 플래그에 대한 ACK를 보냄 (TIMED_WAIT)

Server에서 전송한 FIN 보다 Client에 늦게 도착하는 패킷이 있는 경우, Client는 이미 Server의 FIN 플래그를 받고 세션을 종료시킨 상태이기 때문에 이 패킷은 유실되게 된다. 이러한 경우를 방지하기 위해 Client는 Server로부터 FIN을 수신하더라도 일정시간 동안 세션을 남겨놓고 잉여 패킷을 기다리게 된다. 이 과정을 **TIMED_WAIT** 라고 한다.

## UDP 프로토콜 (User Datagram Protocol)

TCP 프로토콜이 제공하는 신뢰성 전송, 연결 제어 등의 서비스를 제공하지 않기 때문에 오버헤드가 적다. 그렇기 때문에 신뢰성이 떨어져도 되지만 많은 요청을 처리해줘야 하는 경우에 쓰인다.

* DNS
* VoIP
* 온라인 게임 서버